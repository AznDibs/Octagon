{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Home Octagon is a fully fledged modular server sided anti exploit designed to detect many exploits reliably without interrupting user experience. Supported detections Currently, Octagon supports the following physics / non physics detections. As newer versions come, Octagon will eventually support more detections. Physics : High horizontal speed High vertical speed NoClip NonPhysics : Multi tool equip Invalid primary part deletion How effective is it at stopping exploits and how performance friendly is it? Firstly, Octagon already comes with preinstalled physics and non physics detections. If Octagon sees the player movement being invalid ( high vertical or horizontal speed or no clip (if enabled) ), then the player will be safely teleported to their last position and their network ownership temporarily taken away from them which temporarily results in a jerky movement but makes it near-impossible for the player to perform physics exploit. It is also safe to say that each exploit detection is extremely battle tested and are very reliable. Note that Octagon never relies on any information from the client, it already performs physics checks rather than checking client sided computated values like Humaniod.FloorMaterial or Humanoid StateTypes which can be easily spoofed by the client. False positives With every serversided anti exploit, false positives will sometimes appear due to replication latency of the player's position to the server. Octagon is designed in such a way that it safely computes the maximum vertical and horizontal speed of the player based on their jump power, jump height, walk speed and also accounting for gravity and changes in any of these properties. It is worth mentioning that these detections are extremely reliable based off of heavy testing and logic. Flexiblity and scalability Octagon is extremely flexible, and you can easily adjust it to easily suit your own game's need without any headaches. Octagon already comes with group configuration support and manual player black listing from being monitored. Heck, it even allows you to toggle current detections and even create new ones (not currently documented yet). As a bonus, one of the best features of Octagon is that it respects serverside changes. Meaning that changing walk speed, teleporting the player or any property that impacts physics / non physics on the server for a specific player, will cause no issues and Octagon will not falsely detect the player! Performance By using a single Heartbeat event to monitor all players in the game, it is performance friendly and uses something which I call physics cache (which caches physics computation value for later reuse). Here are some concluded benchmarks against other anti exploits: Open the image in a new tab to view it in a clear way Why use Octagon over anti exploits? Doesn't perform heavy computation and reserves resources - Octagon is an extremely performant anti exploit as it doesn't perform heavy computation. Many other anti exploits perform very poorly which is bad for both developer experience and games. Easiness of usage - Octagon is very easy to use and can be easily imported to your game without any headaches. It doesn't provide bloated methods and allows you to use it to it's fullest capability. Handles nightmarish edge cases no developer would ever dare to fix - Octagon is the most reliable anti exploit as of writing, and handles a lot of nightmarish edge cases which are guaranteed to arise when developing a reliable anti exploit. Built for flexibility and massive scalability - Octagon is extremely flexible, you can add your own checks alongside others without any headaches and is built to perform in large-player servers reliably. It spreads a single Heartbeat event for all players in the game. Future proof - Octagon already provides group configuration support along side manual player blacklisting so you'll never be left in the dark and will almost never interrupt UX except very slightly in a rare case .","title":"Home"},{"location":"#home","text":"Octagon is a fully fledged modular server sided anti exploit designed to detect many exploits reliably without interrupting user experience.","title":"Home"},{"location":"#supported-detections","text":"Currently, Octagon supports the following physics / non physics detections. As newer versions come, Octagon will eventually support more detections. Physics : High horizontal speed High vertical speed NoClip NonPhysics : Multi tool equip Invalid primary part deletion","title":"Supported detections"},{"location":"#how-effective-is-it-at-stopping-exploits-and-how-performance-friendly-is-it","text":"Firstly, Octagon already comes with preinstalled physics and non physics detections. If Octagon sees the player movement being invalid ( high vertical or horizontal speed or no clip (if enabled) ), then the player will be safely teleported to their last position and their network ownership temporarily taken away from them which temporarily results in a jerky movement but makes it near-impossible for the player to perform physics exploit. It is also safe to say that each exploit detection is extremely battle tested and are very reliable. Note that Octagon never relies on any information from the client, it already performs physics checks rather than checking client sided computated values like Humaniod.FloorMaterial or Humanoid StateTypes which can be easily spoofed by the client.","title":"How effective is it at stopping exploits and how performance friendly is it?"},{"location":"#false-positives","text":"With every serversided anti exploit, false positives will sometimes appear due to replication latency of the player's position to the server. Octagon is designed in such a way that it safely computes the maximum vertical and horizontal speed of the player based on their jump power, jump height, walk speed and also accounting for gravity and changes in any of these properties. It is worth mentioning that these detections are extremely reliable based off of heavy testing and logic.","title":"False positives"},{"location":"#flexiblity-and-scalability","text":"Octagon is extremely flexible, and you can easily adjust it to easily suit your own game's need without any headaches. Octagon already comes with group configuration support and manual player black listing from being monitored. Heck, it even allows you to toggle current detections and even create new ones (not currently documented yet). As a bonus, one of the best features of Octagon is that it respects serverside changes. Meaning that changing walk speed, teleporting the player or any property that impacts physics / non physics on the server for a specific player, will cause no issues and Octagon will not falsely detect the player!","title":"Flexiblity and scalability"},{"location":"#performance","text":"By using a single Heartbeat event to monitor all players in the game, it is performance friendly and uses something which I call physics cache (which caches physics computation value for later reuse). Here are some concluded benchmarks against other anti exploits:","title":"Performance"},{"location":"#open-the-image-in-a-new-tab-to-view-it-in-a-clear-way","text":"","title":"Open the image in a new tab to view it in a clear way"},{"location":"#why-use-octagon-over-anti-exploits","text":"Doesn't perform heavy computation and reserves resources - Octagon is an extremely performant anti exploit as it doesn't perform heavy computation. Many other anti exploits perform very poorly which is bad for both developer experience and games. Easiness of usage - Octagon is very easy to use and can be easily imported to your game without any headaches. It doesn't provide bloated methods and allows you to use it to it's fullest capability. Handles nightmarish edge cases no developer would ever dare to fix - Octagon is the most reliable anti exploit as of writing, and handles a lot of nightmarish edge cases which are guaranteed to arise when developing a reliable anti exploit. Built for flexibility and massive scalability - Octagon is extremely flexible, you can add your own checks alongside others without any headaches and is built to perform in large-player servers reliably. It spreads a single Heartbeat event for all players in the game. Future proof - Octagon already provides group configuration support along side manual player blacklisting so you'll never be left in the dark and will almost never interrupt UX except very slightly in a rare case .","title":"Why use Octagon over anti exploits?"},{"location":"Basicusage/","text":"Here's some basic serverside code (should be parented to ServerScriptService ) which starts up Octagon and listens to player's exploit detection flags: local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Players = game : GetService ( \"Players\" ) local Octagon = require ( ReplicatedStorage . Octagon ) local PlayerProfileService = require ( Octagon . PlayerProfileService ) -- Start up Octagon: Octagon . Start () local function PlayerAdded ( player ) local profile = PlayerProfileService . GetPlayerProfile ( player ) -- Safe check as the player's profile will not exist if the player -- isn't being monitored by the anti exploit: if not profile then return nil end -- Listen to new physics detection flags: profile . OnPhysicsDetectionFlag : Connect ( function ( detectionFlag ) warn (( \"%s got flagged for %s\" ): format ( player . Name , detectionFlag )) end ) return nil end -- Scripts are deferred when they run, handle the edge case where players are already -- in the game by the time this script runs: for _ , player in ipairs ( Players : GetPlayers ()) do task . spawn ( PlayerAdded , player ) end Players . PlayerAdded : Connect ( PlayerAdded ) Additionally, here is a very basic client side code (should be parented to StarterPlayerScripts ) which starts up Octagon on the client side. For clarification, it will monitor the player's humanoid state and stops them from bouncing high up when they fall to the ground (to prevent false positive) and resets their velocity when flinged (to prevent false positive). local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Octagon = require ( ReplicatedStorage . Octagon ) -- Start up octagon: Octagon . Start ()","title":"Basic usage"},{"location":"Blacklistingplayersfrombeingmonitored/","text":"Blacklisting players from being monitored Octagon provides a way to black list players from being monitored. This is useful for games that make use of admin commands or if you want to black list admins, specific players, etc. The below example which black lists players from being monitored who have a minimum group rank of 35 inside this group which has the group id of 8876330 . -- SilentsReplacement -- Config -- July 20, 2021 --[[ Example setup: return { ShouldMonitorGameOwner = true, PlayersBlackListedFromBeingMonitored = { [124236236] = true, -- 124236236 being the user id of a player GroupConfig = { [8876330] = { MinimumPlayerGroupRank = 35, RequiredPlayerGroupRank = nil, } }, }, } ]] return { ShouldMonitorGameOwner = true , PlayersBlackListedFromBeingMonitored = { GroupConfig = { [ 8876330 ] = { MinimumPlayerGroupRank = 35 , RequiredPlayerGroupRank = nil , }, }, }, } You can also add in more groups if you'd like. The below example black lists players from being monitored who have a minimum group rank of 35 inside this group which has the group id of 8876330 or players who have a minimum group rank of 10 inside this group which has the group id of 3059674 . -- SilentsReplacement -- Config -- July 20, 2021 --[[ Example setup: return { ShouldMonitorGameOwner = true, PlayersBlackListedFromBeingMonitored = { [124236236] = true, -- 124236236 being the user id of a player GroupConfig = { [8876330] = { MinimumPlayerGroupRank = 35, RequiredPlayerGroupRank = nil, } }, }, } ]] return { ShouldMonitorGameOwner = true , PlayersBlackListedFromBeingMonitored = { GroupConfig = { [ 8876330 ] = { MinimumPlayerGroupRank = 35 , RequiredPlayerGroupRank = nil , }, [ 3059674 ] = { MinimumPlayerGroupRank = 10 , RequiredPlayerGroupRank = nil , }, }, }, } You also can black list certain people specifically like so. The below example black lists players who have a user id of 700264840 or 1253464373 . -- SilentsReplacement -- Config -- July 20, 2021 --[[ Example setup: return { ShouldMonitorGameOwner = true, PlayersBlackListedFromBeingMonitored = { [124236236] = true, -- 124236236 being the user id of a player GroupConfig = { [8876330] = { MinimumPlayerGroupRank = 35, RequiredPlayerGroupRank = nil, } }, }, } ]] return { ShouldMonitorGameOwner = true , PlayersBlackListedFromBeingMonitored = { [ 700264840 ] = true , [ 1253464373 ] = true , GroupConfig = {}, }, } Lastly, you can even combine both solutions: -- SilentsReplacement -- Config -- July 20, 2021 --[[ Example setup: return { ShouldMonitorGameOwner = true, PlayersBlackListedFromBeingMonitored = { [124236236] = true, -- 124236236 being the user id of a player GroupConfig = { [8876330] = { MinimumPlayerGroupRank = 35, RequiredPlayerGroupRank = nil, } }, }, } ]] return { ShouldMonitorGameOwner = true , PlayersBlackListedFromBeingMonitored = { [ 700264840 ] = true , [ 1253464373 ] = true , GroupConfig = { [ 8876330 ] = { MinimumPlayerGroupRank = 35 , RequiredPlayerGroupRank = nil , }, [ 3059674 ] = { MinimumPlayerGroupRank = 10 , RequiredPlayerGroupRank = nil , }, }, }, }","title":"Blacklisting players from being monitored"},{"location":"Blacklistingplayersfrombeingmonitored/#blacklisting-players-from-being-monitored","text":"Octagon provides a way to black list players from being monitored. This is useful for games that make use of admin commands or if you want to black list admins, specific players, etc. The below example which black lists players from being monitored who have a minimum group rank of 35 inside this group which has the group id of 8876330 . -- SilentsReplacement -- Config -- July 20, 2021 --[[ Example setup: return { ShouldMonitorGameOwner = true, PlayersBlackListedFromBeingMonitored = { [124236236] = true, -- 124236236 being the user id of a player GroupConfig = { [8876330] = { MinimumPlayerGroupRank = 35, RequiredPlayerGroupRank = nil, } }, }, } ]] return { ShouldMonitorGameOwner = true , PlayersBlackListedFromBeingMonitored = { GroupConfig = { [ 8876330 ] = { MinimumPlayerGroupRank = 35 , RequiredPlayerGroupRank = nil , }, }, }, } You can also add in more groups if you'd like. The below example black lists players from being monitored who have a minimum group rank of 35 inside this group which has the group id of 8876330 or players who have a minimum group rank of 10 inside this group which has the group id of 3059674 . -- SilentsReplacement -- Config -- July 20, 2021 --[[ Example setup: return { ShouldMonitorGameOwner = true, PlayersBlackListedFromBeingMonitored = { [124236236] = true, -- 124236236 being the user id of a player GroupConfig = { [8876330] = { MinimumPlayerGroupRank = 35, RequiredPlayerGroupRank = nil, } }, }, } ]] return { ShouldMonitorGameOwner = true , PlayersBlackListedFromBeingMonitored = { GroupConfig = { [ 8876330 ] = { MinimumPlayerGroupRank = 35 , RequiredPlayerGroupRank = nil , }, [ 3059674 ] = { MinimumPlayerGroupRank = 10 , RequiredPlayerGroupRank = nil , }, }, }, } You also can black list certain people specifically like so. The below example black lists players who have a user id of 700264840 or 1253464373 . -- SilentsReplacement -- Config -- July 20, 2021 --[[ Example setup: return { ShouldMonitorGameOwner = true, PlayersBlackListedFromBeingMonitored = { [124236236] = true, -- 124236236 being the user id of a player GroupConfig = { [8876330] = { MinimumPlayerGroupRank = 35, RequiredPlayerGroupRank = nil, } }, }, } ]] return { ShouldMonitorGameOwner = true , PlayersBlackListedFromBeingMonitored = { [ 700264840 ] = true , [ 1253464373 ] = true , GroupConfig = {}, }, } Lastly, you can even combine both solutions: -- SilentsReplacement -- Config -- July 20, 2021 --[[ Example setup: return { ShouldMonitorGameOwner = true, PlayersBlackListedFromBeingMonitored = { [124236236] = true, -- 124236236 being the user id of a player GroupConfig = { [8876330] = { MinimumPlayerGroupRank = 35, RequiredPlayerGroupRank = nil, } }, }, } ]] return { ShouldMonitorGameOwner = true , PlayersBlackListedFromBeingMonitored = { [ 700264840 ] = true , [ 1253464373 ] = true , GroupConfig = { [ 8876330 ] = { MinimumPlayerGroupRank = 35 , RequiredPlayerGroupRank = nil , }, [ 3059674 ] = { MinimumPlayerGroupRank = 10 , RequiredPlayerGroupRank = nil , }, }, }, }","title":"Blacklisting players from being monitored"},{"location":"Detections/","text":"Detections Octagon already comes with preinstalled physics and non physics detections of course. They can be extremely easily be configured for your own game's needs and you can even create your own custom physics detections. Physics By default, Octagon comes with the following physics detections: NoClip HorizontalSpeed VerticalSpeed How do they work? NoClip This detection by default, checks if the player (who is being monitored) has no clipped through an instance reliably. If these conditions are true, then the player is flagged for no clip, teleported to their last CFrame (just before they no clipped) and their network ownership temporarily taken away from them. HorizontalSpeed This detection by default, checks if the player (who is being monitored) is walking / teleported / has teleported significantly higher than their walk speed is capable of. If these conditions are true, then the player is flagged for high horizontal speed, teleported to their last CFrame (just before these conditions were true) and their network ownership temporarily taken away from them. VerticalSpeed This detection works exactly like the above one, but for high vertical speed. Sneak peak of a physics detection: -- SilentsReplacement -- HorizontalSpeed -- July 18, 2021 --[[ HorizontalSpeed.Leeway : number HorizontalSpeed.StartInterval : number HorizontalSpeed.PlayerDetectionFlagExpireInterval : number HorizontalSpeed.LeewayMultiplier : number HorizontalSpeed.Enabled : boolean HorizontalSpeed.Init() --> nil [] HorizontalSpeed.Start( detectionData : table playerProfile : PlayerProfile dt : number ) --> nil [] ]] local HorizontalSpeed = { Leeway = 8 , StartInterval = 0.3 , PlayerDetectionFlagExpireInterval = 4 , LeewayMultiplier = 1.3 , Enabled = true , } ... Each physics detection, comes with a predefined set of members which you can toggle for your own game's need: PhysicsDetection.Leeway PhysicsDetection . Leeway : number For each physics threshold, an additional amount of value is considered which is referred to as \"Leeway\". Note It is recommended to have this value set to a number greater than or equal to 8 to reduce the chance of false positives. PhysicsDetection.StartInterval PhysicsDetection . StartInterval : number The interval (in seconds) at which the physics detection runs. PhysicsDetection.PlayerDetectionFlagExpireInterval PhysicsDetection . PlayerDetectionFlagExpireInterval : number The interval (in seconds) at which the player(who is currently flagged by the physics detection)'s flag expires. Note It is recommended to have this value set to a number lower than or equal to 4 to reduce the chance of false positives. PhysicsDetection.LeewayMultiplier PhysicsDetection . LeewayMultiplier : number The multiplier for the leeway, used internally by Octagon when calculating the max physics threshold. Note It is recommended to have this value set to a number greater than or equal to 2.5 to reduce the chance of false positives. PhysicsDetection.Enabled PhysicsDetection . Enabled : boolean A boolean indicating if this detection should run or not. NonPhysics By default, Octagon comes with the following non physics detections: MultiToolEquip PrimaryPartDeletion How do they work? Note Non physics detections do not flag the player as non physics detections are mostly caused by glitches / bugs by the engine. MultiToolEquip This detection by default, tracks the equipped tools for the player, and if the number of equipped tools exceed higher than the limit MaxEquippedToolCount (which is 1 as a constant), then the extra equipped tools will be parented back to the player's backpack. PrimaryPartDeletion This detection by default, tracks the primary part (HumanoidRootPart) of the player's character, and if the primary part is deleted (by the client or through some other method), then the player's character will be loadd again and the player will flagged for primary part deletion. Tip The server can safely delete the primary part of the player only through Instance:Destroy and the detection will not reload the player's character. Sneak peak of a non physics detection: -- SilentsReplacement -- MultiToolEquip -- July 26, 2021 --[[ MultiToolEquip.Enabled : boolean MultiToolEquip.Init() --> nil [] MultiToolEquip.Start(playerProfile : PlayerProfile) --> nil [] MultiToolEquip.Stop() --> nil [] ]] local MultiToolEquip = { Enabled = true , } ... Each non physics detection by default, comes with a predefined set of members which you can toggle for your own game's need: NonPhysicsDetection.Enabled NonPhysicsDetection . Enabled : boolean A boolean indicating if the non physics detection should run or not.","title":"Detections"},{"location":"Detections/#detections","text":"Octagon already comes with preinstalled physics and non physics detections of course. They can be extremely easily be configured for your own game's needs and you can even create your own custom physics detections.","title":"Detections"},{"location":"Detections/#physics","text":"By default, Octagon comes with the following physics detections: NoClip HorizontalSpeed VerticalSpeed","title":"Physics"},{"location":"Detections/#how-do-they-work","text":"","title":"How do they work?"},{"location":"Detections/#noclip","text":"This detection by default, checks if the player (who is being monitored) has no clipped through an instance reliably. If these conditions are true, then the player is flagged for no clip, teleported to their last CFrame (just before they no clipped) and their network ownership temporarily taken away from them.","title":"NoClip"},{"location":"Detections/#horizontalspeed","text":"This detection by default, checks if the player (who is being monitored) is walking / teleported / has teleported significantly higher than their walk speed is capable of. If these conditions are true, then the player is flagged for high horizontal speed, teleported to their last CFrame (just before these conditions were true) and their network ownership temporarily taken away from them.","title":"HorizontalSpeed"},{"location":"Detections/#verticalspeed","text":"This detection works exactly like the above one, but for high vertical speed. Sneak peak of a physics detection: -- SilentsReplacement -- HorizontalSpeed -- July 18, 2021 --[[ HorizontalSpeed.Leeway : number HorizontalSpeed.StartInterval : number HorizontalSpeed.PlayerDetectionFlagExpireInterval : number HorizontalSpeed.LeewayMultiplier : number HorizontalSpeed.Enabled : boolean HorizontalSpeed.Init() --> nil [] HorizontalSpeed.Start( detectionData : table playerProfile : PlayerProfile dt : number ) --> nil [] ]] local HorizontalSpeed = { Leeway = 8 , StartInterval = 0.3 , PlayerDetectionFlagExpireInterval = 4 , LeewayMultiplier = 1.3 , Enabled = true , } ... Each physics detection, comes with a predefined set of members which you can toggle for your own game's need:","title":"VerticalSpeed"},{"location":"Detections/#physicsdetectionleeway","text":"PhysicsDetection . Leeway : number For each physics threshold, an additional amount of value is considered which is referred to as \"Leeway\". Note It is recommended to have this value set to a number greater than or equal to 8 to reduce the chance of false positives.","title":"PhysicsDetection.Leeway"},{"location":"Detections/#physicsdetectionstartinterval","text":"PhysicsDetection . StartInterval : number The interval (in seconds) at which the physics detection runs.","title":"PhysicsDetection.StartInterval"},{"location":"Detections/#physicsdetectionplayerdetectionflagexpireinterval","text":"PhysicsDetection . PlayerDetectionFlagExpireInterval : number The interval (in seconds) at which the player(who is currently flagged by the physics detection)'s flag expires. Note It is recommended to have this value set to a number lower than or equal to 4 to reduce the chance of false positives.","title":"PhysicsDetection.PlayerDetectionFlagExpireInterval"},{"location":"Detections/#physicsdetectionleewaymultiplier","text":"PhysicsDetection . LeewayMultiplier : number The multiplier for the leeway, used internally by Octagon when calculating the max physics threshold. Note It is recommended to have this value set to a number greater than or equal to 2.5 to reduce the chance of false positives.","title":"PhysicsDetection.LeewayMultiplier"},{"location":"Detections/#physicsdetectionenabled","text":"PhysicsDetection . Enabled : boolean A boolean indicating if this detection should run or not.","title":"PhysicsDetection.Enabled"},{"location":"Detections/#nonphysics","text":"By default, Octagon comes with the following non physics detections: MultiToolEquip PrimaryPartDeletion","title":"NonPhysics"},{"location":"Detections/#how-do-they-work_1","text":"Note Non physics detections do not flag the player as non physics detections are mostly caused by glitches / bugs by the engine.","title":"How do they work?"},{"location":"Detections/#multitoolequip","text":"This detection by default, tracks the equipped tools for the player, and if the number of equipped tools exceed higher than the limit MaxEquippedToolCount (which is 1 as a constant), then the extra equipped tools will be parented back to the player's backpack.","title":"MultiToolEquip"},{"location":"Detections/#primarypartdeletion","text":"This detection by default, tracks the primary part (HumanoidRootPart) of the player's character, and if the primary part is deleted (by the client or through some other method), then the player's character will be loadd again and the player will flagged for primary part deletion. Tip The server can safely delete the primary part of the player only through Instance:Destroy and the detection will not reload the player's character. Sneak peak of a non physics detection: -- SilentsReplacement -- MultiToolEquip -- July 26, 2021 --[[ MultiToolEquip.Enabled : boolean MultiToolEquip.Init() --> nil [] MultiToolEquip.Start(playerProfile : PlayerProfile) --> nil [] MultiToolEquip.Stop() --> nil [] ]] local MultiToolEquip = { Enabled = true , } ... Each non physics detection by default, comes with a predefined set of members which you can toggle for your own game's need:","title":"PrimaryPartDeletion"},{"location":"Detections/#nonphysicsdetectionenabled","text":"NonPhysicsDetection . Enabled : boolean A boolean indicating if the non physics detection should run or not.","title":"NonPhysicsDetection.Enabled"},{"location":"Settingup/","text":"Setting up Octagon is designed to be a module script that you need to place in ReplicatedStorage as both the server and client are supposed to access it. Through Roblox Studio Get the Roblox model here . Place it in ReplicatedStorage . Through Rojo Fork the repository . Use Rojo to sync the files to your project through an external code editor, preferably Visual Studio Code .","title":"Setting up"},{"location":"Settingup/#setting-up","text":"Octagon is designed to be a module script that you need to place in ReplicatedStorage as both the server and client are supposed to access it.","title":"Setting up"},{"location":"Settingup/#through-roblox-studio","text":"Get the Roblox model here . Place it in ReplicatedStorage .","title":"Through Roblox Studio"},{"location":"Settingup/#through-rojo","text":"Fork the repository . Use Rojo to sync the files to your project through an external code editor, preferably Visual Studio Code .","title":"Through Rojo"},{"location":"Troubleshooting/","text":"Troubleshooting Note Make sure that your Octagon module is completely up to date. It isn't a module which trades in reliability for laziness! False positives Octagon is a server sided anti exploit, meaning there will be sometimes false positives of physics exploits. Octagon is designed in such a way that it will never punish players (such as bans, kicks) for exploiting, as server sided anti exploits can't be perfect due to replication latency. Instead, it teleports them to their last position and temporarily takes away the player's network owner. Note Also make sure to require Octagon on the client side so it checks the humanoid state of the local player and prevents them from bouncing hard when they land on the ground to prevent false positives and prevent them from flinging. Players being monitored/detected despite being black listed in the config module This is due to HTTP requests failing in a rare case, as Octagon checks player's group rank which send in an internal HTTP GET request to determine if they are the owner of the game's group or to determine if they are black listed from being monitored. If that is not the case, then the problem lies with game.CreatorId returning an invalid userid of the game's owner's actual user id due to internal reasons. This only happens in Studio and make sure to test this out in an actual published game. Players being flagged for serverside teleportation Octagon will respect serverside teleportations, walk speed, velocity, jump power changes, etc. However, Octagon will not respect serverside teleportation of the player through the changing of Position , but rather through CFrame for internal reasons. Make sure you change the CFrame of the player's primary part, not Position .","title":"Trouble shooting"},{"location":"Troubleshooting/#troubleshooting","text":"Note Make sure that your Octagon module is completely up to date. It isn't a module which trades in reliability for laziness!","title":"Troubleshooting"},{"location":"Troubleshooting/#false-positives","text":"Octagon is a server sided anti exploit, meaning there will be sometimes false positives of physics exploits. Octagon is designed in such a way that it will never punish players (such as bans, kicks) for exploiting, as server sided anti exploits can't be perfect due to replication latency. Instead, it teleports them to their last position and temporarily takes away the player's network owner. Note Also make sure to require Octagon on the client side so it checks the humanoid state of the local player and prevents them from bouncing hard when they land on the ground to prevent false positives and prevent them from flinging.","title":"False positives"},{"location":"Troubleshooting/#players-being-monitoreddetected-despite-being-black-listed-in-the-config-module","text":"This is due to HTTP requests failing in a rare case, as Octagon checks player's group rank which send in an internal HTTP GET request to determine if they are the owner of the game's group or to determine if they are black listed from being monitored. If that is not the case, then the problem lies with game.CreatorId returning an invalid userid of the game's owner's actual user id due to internal reasons. This only happens in Studio and make sure to test this out in an actual published game.","title":"Players being monitored/detected despite being black listed in the config module"},{"location":"Troubleshooting/#players-being-flagged-for-serverside-teleportation","text":"Octagon will respect serverside teleportations, walk speed, velocity, jump power changes, etc. However, Octagon will not respect serverside teleportation of the player through the changing of Position , but rather through CFrame for internal reasons. Make sure you change the CFrame of the player's primary part, not Position .","title":"Players being flagged for serverside teleportation"},{"location":"Client/API/","text":"API Warning Never edit the source of Octagon or any of it's modules. Octagon is a module not supposed to have it's source code interrupted. Octagon Octagon.OnPlayerFling Octagon . OnPlayerFling : Signal () A signal which is fired whenever the player is flinged (when hit by a fast moving object). Octagon.OnPlayerHardGroundLand Octagon . OnPlayerHardGroundLand : Signal () A signal which is fired whenever the player lands on a ground in a \"hard way\" such that they are likely to bounce back. Octagon.Start() Octagon . Start () --> nil [] Starts checking the humanoid state of the client for fling detections. Octagon.IsStarted() Octagon . IsStarted () --> boolean [IsStarted] Returns a boolean indicating if Octagon is started through Octagon.Start() . Octagon.IsStopped() Octagon . IsStopped () --> boolean [IsStopped] Returns a boolean indicating if Octagon is stopped through Octagon.Stop() . Octagon.Stop() Octagon . Stop () --> nil [] Cleans up all maids in use.","title":"API"},{"location":"Client/API/#api","text":"Warning Never edit the source of Octagon or any of it's modules. Octagon is a module not supposed to have it's source code interrupted.","title":"API"},{"location":"Client/API/#octagon","text":"","title":"Octagon"},{"location":"Client/API/#octagononplayerfling","text":"Octagon . OnPlayerFling : Signal () A signal which is fired whenever the player is flinged (when hit by a fast moving object).","title":"Octagon.OnPlayerFling"},{"location":"Client/API/#octagononplayerhardgroundland","text":"Octagon . OnPlayerHardGroundLand : Signal () A signal which is fired whenever the player lands on a ground in a \"hard way\" such that they are likely to bounce back.","title":"Octagon.OnPlayerHardGroundLand"},{"location":"Client/API/#octagonstart","text":"Octagon . Start () --> nil [] Starts checking the humanoid state of the client for fling detections.","title":"Octagon.Start()"},{"location":"Client/API/#octagonisstarted","text":"Octagon . IsStarted () --> boolean [IsStarted] Returns a boolean indicating if Octagon is started through Octagon.Start() .","title":"Octagon.IsStarted()"},{"location":"Client/API/#octagonisstopped","text":"Octagon . IsStopped () --> boolean [IsStopped] Returns a boolean indicating if Octagon is stopped through Octagon.Stop() .","title":"Octagon.IsStopped()"},{"location":"Client/API/#octagonstop","text":"Octagon . Stop () --> nil [] Cleans up all maids in use.","title":"Octagon.Stop()"},{"location":"Server/API/","text":"API Warning Never edit the source of Octagon or any of it's modules. Octagon is a module not supposed to have it's source code interrupted. Note Octagon will not monitor players whose profiles were cleaned up / not loaded. Octagon Octagon.MonitoringPlayerProfiles Octagon . MonitoringPlayerProfiles : table An dictionary of all player profiles being monitored by Octagon. Octagon.Start() Octagon . Start () --> nil [] Starts up Octagon and starts monitoring players who aren't black listed from being monitored. Octagon.Stop() Octagon . Stop () --> nil [] Cleans up all maids in use, destroys all loaded player profiles and stops monitoring players. Octagon.IsStarted() Octagon . IsStarted () --> boolean [IsStarted] Returns a boolean indicating if Octagon is started through Octagon.Start() . Octagon.IsStopped() Octagon . IsStopped () --> boolean [IsStopped] Returns a boolean indicating if Octagon is stopped through [Octagon.Stop()]https://silentsreplacement.github.io/Octagon/Server/API/#octagonstop). Octagon.IsPlayerGameOwner() Octagon . IsPlayerGameOwner ( player : Player ) --> boolean [IsPlayerGameOwner] Returns a boolean indicating if the player is the owner of the game or the owner of the group the game is in. Arguments Description player : Player A Player object Note This method may temporarily yield the thread if the game is under a group as it will send an GET HTTP request to retrieve player 's rank in order to determine if player is the owner of that group. Octagon.BlacklistNoClipMonitoringParts() Octagon . BlacklistNoClipMonitoringParts ( parts : table ) --> nil [] Iterates through parts and adds a noclip black listed tag which will allow players to pass through those parts even if they aren't CanCollide true on the server. Arguments Description parts : table An array of base parts Octagon.UnBlacklistNoClipMonitoringParts() Octagon . UnBlacklistNoClipMonitoringParts ( parts : table ) --> nil [] Iterates through parts and removes the noclip black listed tag. Arguments Description parts : table An array of base parts Octagon.TemporarilyBlacklistPlayerFromBeingMonitored() Octagon . TemporarilyBlacklistPlayerFromBeingMonitored ( player : Player , value : number | RBXScriptSignal | function ) --> nil [] Temporarily black lists the player from being monitored by Octagon. Arguments Description player : Player A Player object value : number The number of seconds before the player will be monitored again by Octagon value : function The function to be called and done executed before the player will be monitored again by Octagon. value : RBXScriptSignal | Signal A signal (which contains a Wait method) or a RBXScriptSignal, whose Wait method will be called and done completing before the player will be monitored again by Octagon Octagon.IsPlayerSubjectToBeMonitored() Server . IsPlayerSubjectToBeMonitored ( player : Player ) --> boolean [IsPlayerSubjectToBeMonitored] Returns a boolean indicating if player is going to be monitored by Octagon or not. Arguments Description player : Player A Player object Note This method may temporarily yield the thread as it checks to see if the player is black listed through the Config module which may send an GET HTTP request to retrieve the player's rank.","title":"API"},{"location":"Server/API/#api","text":"Warning Never edit the source of Octagon or any of it's modules. Octagon is a module not supposed to have it's source code interrupted. Note Octagon will not monitor players whose profiles were cleaned up / not loaded.","title":"API"},{"location":"Server/API/#octagon","text":"","title":"Octagon"},{"location":"Server/API/#octagonmonitoringplayerprofiles","text":"Octagon . MonitoringPlayerProfiles : table An dictionary of all player profiles being monitored by Octagon.","title":"Octagon.MonitoringPlayerProfiles"},{"location":"Server/API/#octagonstart","text":"Octagon . Start () --> nil [] Starts up Octagon and starts monitoring players who aren't black listed from being monitored.","title":"Octagon.Start()"},{"location":"Server/API/#octagonstop","text":"Octagon . Stop () --> nil [] Cleans up all maids in use, destroys all loaded player profiles and stops monitoring players.","title":"Octagon.Stop()"},{"location":"Server/API/#octagonisstarted","text":"Octagon . IsStarted () --> boolean [IsStarted] Returns a boolean indicating if Octagon is started through Octagon.Start() .","title":"Octagon.IsStarted()"},{"location":"Server/API/#octagonisstopped","text":"Octagon . IsStopped () --> boolean [IsStopped] Returns a boolean indicating if Octagon is stopped through [Octagon.Stop()]https://silentsreplacement.github.io/Octagon/Server/API/#octagonstop).","title":"Octagon.IsStopped()"},{"location":"Server/API/#octagonisplayergameowner","text":"Octagon . IsPlayerGameOwner ( player : Player ) --> boolean [IsPlayerGameOwner] Returns a boolean indicating if the player is the owner of the game or the owner of the group the game is in. Arguments Description player : Player A Player object Note This method may temporarily yield the thread if the game is under a group as it will send an GET HTTP request to retrieve player 's rank in order to determine if player is the owner of that group.","title":"Octagon.IsPlayerGameOwner()"},{"location":"Server/API/#octagonblacklistnoclipmonitoringparts","text":"Octagon . BlacklistNoClipMonitoringParts ( parts : table ) --> nil [] Iterates through parts and adds a noclip black listed tag which will allow players to pass through those parts even if they aren't CanCollide true on the server. Arguments Description parts : table An array of base parts","title":"Octagon.BlacklistNoClipMonitoringParts()"},{"location":"Server/API/#octagonunblacklistnoclipmonitoringparts","text":"Octagon . UnBlacklistNoClipMonitoringParts ( parts : table ) --> nil [] Iterates through parts and removes the noclip black listed tag. Arguments Description parts : table An array of base parts","title":"Octagon.UnBlacklistNoClipMonitoringParts()"},{"location":"Server/API/#octagontemporarilyblacklistplayerfrombeingmonitored","text":"Octagon . TemporarilyBlacklistPlayerFromBeingMonitored ( player : Player , value : number | RBXScriptSignal | function ) --> nil [] Temporarily black lists the player from being monitored by Octagon. Arguments Description player : Player A Player object value : number The number of seconds before the player will be monitored again by Octagon value : function The function to be called and done executed before the player will be monitored again by Octagon. value : RBXScriptSignal | Signal A signal (which contains a Wait method) or a RBXScriptSignal, whose Wait method will be called and done completing before the player will be monitored again by Octagon","title":"Octagon.TemporarilyBlacklistPlayerFromBeingMonitored()"},{"location":"Server/API/#octagonisplayersubjecttobemonitored","text":"Server . IsPlayerSubjectToBeMonitored ( player : Player ) --> boolean [IsPlayerSubjectToBeMonitored] Returns a boolean indicating if player is going to be monitored by Octagon or not. Arguments Description player : Player A Player object Note This method may temporarily yield the thread as it checks to see if the player is black listed through the Config module which may send an GET HTTP request to retrieve the player's rank.","title":"Octagon.IsPlayerSubjectToBeMonitored()"},{"location":"Server/PlayerProfile/","text":"PlayerProfile A player profile in layman's terms, is simply a table which contains necessary data for Octagon and the developer to work with. Note To retrieve a player profile, only use PlayerProfileService.GetPlayerProfile() . PlayerProfile.IsPlayerProfile() PlayerProfile . IsPlayerProfile ( self : any ) --> boolean [IsPlayerProfile] Arguments Description self : any Any value Returns a boolean indicating if self is a player profile or not. Only accessible from an object created by the PlayerProfile.new: Warning Never cleanup any maids or signals, this is done by Octagon automatically whenever the profile associated to a player leaves. Doing so will cause a lot of errors and break a lot of functionality! PlayerProfile.Player PlayerProfile . Player : Player A reference to the player who owns the profile. PlayerProfile.Maid PlayerProfile . Maid : Maid A reference to a maid object, used for cleaning up signals. PlayerProfile.DetectionMaid PlayerProfile . DetectionMaid : Maid A reference to a maid object, used for cleaning up signals regarding non physics detections. PlayerProfile.PhysicsDetectionFlagsHistory PlayerProfile . PhysicsDetectionFlagsHistory : table An array of physics detection flags accumulated by the player who owns this profile. PlayerProfile.PhysicsDetectionFlagCount PlayerProfile . PhysicsDetectionFlagCount : number The number of physics detection flags accumulated by the player who owns this profile. PlayerProfile.OnPhysicsDetectionFlag PlayerProfile . OnPhysicsDetectionFlag : Signal ( detectionFlag : string ) A signal which is fired whenever the player is flagged by a detection through PlayerProfile:RegisterPhysicsDetectionFlag . PlayerProfile . OnPhysicsDetectionFlag : Connect ( function ( flag ) warn (( \"%s was flagged for %s\" ): format ( PlayerProfile . Player , flag )) end ) Parameters Description flag : string The flag by the detection (for e.g HighHorizontalSpeed , HighVerticalSpeed ) PlayerProfile.OnPhysicsDetectionFlagExpire PlayerProfile . OnPhysicsDetectionFlagExpire : Signal ( expiredFlag : string ) A signal which is fired whenever the player's flag by a physics detection is expired periodically. When this signal is fired, the physics detections by default, will give back the network ownership from the server to the player and return the player to a normal state. PlayerProfile . OnPhysicsDetectionFlagExpire : Connect ( function ( expiredFlag ) warn (( \"%s's %s flag has been expired\" ): format ( PlayerProfile . Player , expiredFlag )) end ) Parameters Description expiredFlag : string The now expired flag by the detection (for e.g HighHorizontalSpeed , HighVerticalSpeed ) PlayerProfile:RegisterPhysicsDetectionFlag() PlayerProfile : RegisterPhysicsDetectionFlag ( detectionName : string , flag : string ) --> nil [] Register a new flag, incrementing PlayerProfile.PhysicsDetectionFlagCount by 1 and adds flag to the player profile's physics detection history and fires PlayerProfile.OnPhysicsDetectionFlag passing in flag as the argument. Arguments Description detectionName : string The exact name of the physics detection flag : string The flag by the detection, for e.g HighHorizontalSpeed , HighVerticalSpeed . PlayerProfile:IsDestroyed() PlayerProfile : IsDestroyed () --> boolean [IsDestroyed] Returns a boolean indicating if the profile has been destroyed PlayerProfile:IncrementPhysicsThreshold() PlayerProfile : IncrementPhysicsThreshold ( physicsThreshold : string , thresholdIncrement : number ) --> nil [] Increments the threshold for physicsThreshold by thresholdIncrement . Useful for managing player specific thresholds in different scenarios and can greatly reduce false positives if implemented correctly. -- Assuming HorizontalSpeed detection is enabled: humanoid : GetPropertyChangedSignal ( \"WalkSpeed\" ): Connect ( function () profile : DecrementPhysicsThreshold ( \"HorizontalSpeed\" , profile : GetPhysicsThresholdIncrement ( \"HorizontalSpeed\" )) profile : IncrementPhysicsThreshold ( \"HorizontalSpeed\" , math.sqrt ( humanoid . WalkSpeed ) * 2 ) end ) Arguments Description physicsThreshold : string A value which can be either VerticalSpeed or HorizontalSpeed (if the detections for them are enabled) thresholdIncrement : number The value to increment the threshold by PlayerProfile:DecrementPhysicsThreshold() PlayerProfile : DecrementPhysicsThreshold ( physicsThreshold : string , thresholdDecrement : number ) --> nil [] Decrements the threshold for physicsThreshold by thresholdDecrement . Arguments Description physicsThreshold : string A value which can be either VerticalSpeed or HorizontalSpeed (if the detections for them are enabled) thresholdIncrement : number The value to decrement the threshold by Note If decrementing physics threshold values such that they are to be a value <= 0 , they will be clamped to 0 . PlayerProfile : IncrementPhysicsThreshold ( \"VerticalSpeed\" , 500 ) print ( PlayerProfile : GetPhysicsThresholdIncrement ( \"VerticalSpeed\" )) --> 500 PlayerProfile : DecrementPhysicsThreshold ( \"VerticalSpeed\" , 500 ) print ( PlayerProfile : GetPhysicsThresholdIncrement ( \"VerticalSpeed\" )) --> 0 PlayerProfile : DecrementPhysicsThreshold ( \"VerticalSpeed\" , 500 ) print ( PlayerProfile : GetPhysicsThresholdIncrement ( \"VerticalSpeed\" )) --> 0 PlayerProfile:GetPhysicsThresholdIncrement() PlayerProfile : GetPhysicsThresholdIncrement ( physicsThreshold : string ) --> number [thresholdIncrement] Returns the threshold increment for physicsThreshold . Arguments Description physicsThreshold : string A value which can be either VerticalSpeed or HorizontalSpeed (if the detections for them are enabled) PlayerProfile:GetCurrentActivePhysicsDetectionFlag() PlayerProfile : GetCurrentActivePhysicsDetectionFlag () --> string | nil [physicsDetectionFlag] Returns the name of the physics detection whose flag has still not expired.","title":"PlayerProfile"},{"location":"Server/PlayerProfile/#playerprofile","text":"A player profile in layman's terms, is simply a table which contains necessary data for Octagon and the developer to work with. Note To retrieve a player profile, only use PlayerProfileService.GetPlayerProfile() .","title":"PlayerProfile"},{"location":"Server/PlayerProfile/#playerprofileisplayerprofile","text":"PlayerProfile . IsPlayerProfile ( self : any ) --> boolean [IsPlayerProfile] Arguments Description self : any Any value Returns a boolean indicating if self is a player profile or not.","title":"PlayerProfile.IsPlayerProfile()"},{"location":"Server/PlayerProfile/#only-accessible-from-an-object-created-by-the-playerprofilenew","text":"Warning Never cleanup any maids or signals, this is done by Octagon automatically whenever the profile associated to a player leaves. Doing so will cause a lot of errors and break a lot of functionality!","title":"Only accessible from an object created by the PlayerProfile.new:"},{"location":"Server/PlayerProfile/#playerprofileplayer","text":"PlayerProfile . Player : Player A reference to the player who owns the profile.","title":"PlayerProfile.Player"},{"location":"Server/PlayerProfile/#playerprofilemaid","text":"PlayerProfile . Maid : Maid A reference to a maid object, used for cleaning up signals.","title":"PlayerProfile.Maid"},{"location":"Server/PlayerProfile/#playerprofiledetectionmaid","text":"PlayerProfile . DetectionMaid : Maid A reference to a maid object, used for cleaning up signals regarding non physics detections.","title":"PlayerProfile.DetectionMaid"},{"location":"Server/PlayerProfile/#playerprofilephysicsdetectionflagshistory","text":"PlayerProfile . PhysicsDetectionFlagsHistory : table An array of physics detection flags accumulated by the player who owns this profile.","title":"PlayerProfile.PhysicsDetectionFlagsHistory"},{"location":"Server/PlayerProfile/#playerprofilephysicsdetectionflagcount","text":"PlayerProfile . PhysicsDetectionFlagCount : number The number of physics detection flags accumulated by the player who owns this profile.","title":"PlayerProfile.PhysicsDetectionFlagCount"},{"location":"Server/PlayerProfile/#playerprofileonphysicsdetectionflag","text":"PlayerProfile . OnPhysicsDetectionFlag : Signal ( detectionFlag : string ) A signal which is fired whenever the player is flagged by a detection through PlayerProfile:RegisterPhysicsDetectionFlag . PlayerProfile . OnPhysicsDetectionFlag : Connect ( function ( flag ) warn (( \"%s was flagged for %s\" ): format ( PlayerProfile . Player , flag )) end ) Parameters Description flag : string The flag by the detection (for e.g HighHorizontalSpeed , HighVerticalSpeed )","title":"PlayerProfile.OnPhysicsDetectionFlag"},{"location":"Server/PlayerProfile/#playerprofileonphysicsdetectionflagexpire","text":"PlayerProfile . OnPhysicsDetectionFlagExpire : Signal ( expiredFlag : string ) A signal which is fired whenever the player's flag by a physics detection is expired periodically. When this signal is fired, the physics detections by default, will give back the network ownership from the server to the player and return the player to a normal state. PlayerProfile . OnPhysicsDetectionFlagExpire : Connect ( function ( expiredFlag ) warn (( \"%s's %s flag has been expired\" ): format ( PlayerProfile . Player , expiredFlag )) end ) Parameters Description expiredFlag : string The now expired flag by the detection (for e.g HighHorizontalSpeed , HighVerticalSpeed )","title":"PlayerProfile.OnPhysicsDetectionFlagExpire"},{"location":"Server/PlayerProfile/#playerprofileregisterphysicsdetectionflag","text":"PlayerProfile : RegisterPhysicsDetectionFlag ( detectionName : string , flag : string ) --> nil [] Register a new flag, incrementing PlayerProfile.PhysicsDetectionFlagCount by 1 and adds flag to the player profile's physics detection history and fires PlayerProfile.OnPhysicsDetectionFlag passing in flag as the argument. Arguments Description detectionName : string The exact name of the physics detection flag : string The flag by the detection, for e.g HighHorizontalSpeed , HighVerticalSpeed .","title":"PlayerProfile:RegisterPhysicsDetectionFlag()"},{"location":"Server/PlayerProfile/#playerprofileisdestroyed","text":"PlayerProfile : IsDestroyed () --> boolean [IsDestroyed] Returns a boolean indicating if the profile has been destroyed","title":"PlayerProfile:IsDestroyed()"},{"location":"Server/PlayerProfile/#playerprofileincrementphysicsthreshold","text":"PlayerProfile : IncrementPhysicsThreshold ( physicsThreshold : string , thresholdIncrement : number ) --> nil [] Increments the threshold for physicsThreshold by thresholdIncrement . Useful for managing player specific thresholds in different scenarios and can greatly reduce false positives if implemented correctly. -- Assuming HorizontalSpeed detection is enabled: humanoid : GetPropertyChangedSignal ( \"WalkSpeed\" ): Connect ( function () profile : DecrementPhysicsThreshold ( \"HorizontalSpeed\" , profile : GetPhysicsThresholdIncrement ( \"HorizontalSpeed\" )) profile : IncrementPhysicsThreshold ( \"HorizontalSpeed\" , math.sqrt ( humanoid . WalkSpeed ) * 2 ) end ) Arguments Description physicsThreshold : string A value which can be either VerticalSpeed or HorizontalSpeed (if the detections for them are enabled) thresholdIncrement : number The value to increment the threshold by","title":"PlayerProfile:IncrementPhysicsThreshold()"},{"location":"Server/PlayerProfile/#playerprofiledecrementphysicsthreshold","text":"PlayerProfile : DecrementPhysicsThreshold ( physicsThreshold : string , thresholdDecrement : number ) --> nil [] Decrements the threshold for physicsThreshold by thresholdDecrement . Arguments Description physicsThreshold : string A value which can be either VerticalSpeed or HorizontalSpeed (if the detections for them are enabled) thresholdIncrement : number The value to decrement the threshold by Note If decrementing physics threshold values such that they are to be a value <= 0 , they will be clamped to 0 . PlayerProfile : IncrementPhysicsThreshold ( \"VerticalSpeed\" , 500 ) print ( PlayerProfile : GetPhysicsThresholdIncrement ( \"VerticalSpeed\" )) --> 500 PlayerProfile : DecrementPhysicsThreshold ( \"VerticalSpeed\" , 500 ) print ( PlayerProfile : GetPhysicsThresholdIncrement ( \"VerticalSpeed\" )) --> 0 PlayerProfile : DecrementPhysicsThreshold ( \"VerticalSpeed\" , 500 ) print ( PlayerProfile : GetPhysicsThresholdIncrement ( \"VerticalSpeed\" )) --> 0","title":"PlayerProfile:DecrementPhysicsThreshold()"},{"location":"Server/PlayerProfile/#playerprofilegetphysicsthresholdincrement","text":"PlayerProfile : GetPhysicsThresholdIncrement ( physicsThreshold : string ) --> number [thresholdIncrement] Returns the threshold increment for physicsThreshold . Arguments Description physicsThreshold : string A value which can be either VerticalSpeed or HorizontalSpeed (if the detections for them are enabled)","title":"PlayerProfile:GetPhysicsThresholdIncrement()"},{"location":"Server/PlayerProfile/#playerprofilegetcurrentactivephysicsdetectionflag","text":"PlayerProfile : GetCurrentActivePhysicsDetectionFlag () --> string | nil [physicsDetectionFlag] Returns the name of the physics detection whose flag has still not expired.","title":"PlayerProfile:GetCurrentActivePhysicsDetectionFlag()"},{"location":"Server/PlayerProfileService/","text":"PlayerProfileService The PlayerProfileService module provides methods to access player profiles easily. PlayerProfileService.OnPlayerProfileLoaded PlayerProfileService . OnPlayerProfileLoaded : Signal ( playerProfile : PlayerProfile ) A signal which is fired whenever a new player profile is loaded. PlayerProfileService . OnPlayerProfileLoaded : Connect ( function ( playerProfile ) print (( \"%s's profile was loaded\" ): format ( playerProfile . Player )) end Parameters Description playerProfile : PlayerProfile The player profile that was loaded PlayerProfileService.OnPlayerProfileDestroyed PlayerProfileService . OnPlayerProfileDestroyed : Signal ( player : Player ) A signal which is fired whenever a player profile is destroyed through PlayerProfile:Destroy() . PlayerProfileService . OnPlayerProfileDestroyed : Connect ( function ( player ) print (( \"%s's profile was destroyed\" ): format ( player )) end Parameters Description player : Player The player object whose profile was destroyed PlayerProfileService.OnPlayerProfileInit PlayerProfileService . OnPlayerProfileInit : Signal ( playerProfile : PlayerProfile ) A signal which is fired whenever a player's profile is init through PlayerProfile:Init . Parameters Description playerProfile : PlayerProfile The player profile that was init PlayerProfileService.LoadedPlayerProfiles PlayerProfileService . LoadedPlayerProfiles : table A dictionary of all loaded player profiles. PlayerProfileService.GetPlayerProfile() PlayerProfileService . GetPlayerProfile ( player : Player ) --> PlayerProfile | nil [] Returns the player profile. Arguments Description player : Player A Player object Note This method may temporarily yield the thread if the profile isn't initialized yet or not loaded in time. This method will return nil if player is black listed from being monitored by Octagon. PlayerProfileService.ArePlayerProfilesLoaded() PlayerProfileService . ArePlayerProfilesLoaded () --> boolean [ArePlayerProfilesLoaded] Returns a boolean indicating if player profiles have been loaded.","title":"PlayerProfileService"},{"location":"Server/PlayerProfileService/#playerprofileservice","text":"The PlayerProfileService module provides methods to access player profiles easily.","title":"PlayerProfileService"},{"location":"Server/PlayerProfileService/#playerprofileserviceonplayerprofileloaded","text":"PlayerProfileService . OnPlayerProfileLoaded : Signal ( playerProfile : PlayerProfile ) A signal which is fired whenever a new player profile is loaded. PlayerProfileService . OnPlayerProfileLoaded : Connect ( function ( playerProfile ) print (( \"%s's profile was loaded\" ): format ( playerProfile . Player )) end Parameters Description playerProfile : PlayerProfile The player profile that was loaded","title":"PlayerProfileService.OnPlayerProfileLoaded"},{"location":"Server/PlayerProfileService/#playerprofileserviceonplayerprofiledestroyed","text":"PlayerProfileService . OnPlayerProfileDestroyed : Signal ( player : Player ) A signal which is fired whenever a player profile is destroyed through PlayerProfile:Destroy() . PlayerProfileService . OnPlayerProfileDestroyed : Connect ( function ( player ) print (( \"%s's profile was destroyed\" ): format ( player )) end Parameters Description player : Player The player object whose profile was destroyed","title":"PlayerProfileService.OnPlayerProfileDestroyed"},{"location":"Server/PlayerProfileService/#playerprofileserviceonplayerprofileinit","text":"PlayerProfileService . OnPlayerProfileInit : Signal ( playerProfile : PlayerProfile ) A signal which is fired whenever a player's profile is init through PlayerProfile:Init . Parameters Description playerProfile : PlayerProfile The player profile that was init","title":"PlayerProfileService.OnPlayerProfileInit"},{"location":"Server/PlayerProfileService/#playerprofileserviceloadedplayerprofiles","text":"PlayerProfileService . LoadedPlayerProfiles : table A dictionary of all loaded player profiles.","title":"PlayerProfileService.LoadedPlayerProfiles"},{"location":"Server/PlayerProfileService/#playerprofileservicegetplayerprofile","text":"PlayerProfileService . GetPlayerProfile ( player : Player ) --> PlayerProfile | nil [] Returns the player profile. Arguments Description player : Player A Player object Note This method may temporarily yield the thread if the profile isn't initialized yet or not loaded in time. This method will return nil if player is black listed from being monitored by Octagon.","title":"PlayerProfileService.GetPlayerProfile()"},{"location":"Server/PlayerProfileService/#playerprofileserviceareplayerprofilesloaded","text":"PlayerProfileService . ArePlayerProfilesLoaded () --> boolean [ArePlayerProfilesLoaded] Returns a boolean indicating if player profiles have been loaded.","title":"PlayerProfileService.ArePlayerProfilesLoaded()"},{"location":"Shared/Util/","text":"Util The Util module is a simply module which provides a few basic instance methods associated to instances and players. Util.GetPlayerEquippedTools() Util . GetPlayerEquippedTools ( player : Player ) --> table [equippedTools], number [equippedToolsCount] Returns an array of the tools equipped by the player, along with the number of tools equipped. Arguments Description player : Player A Player object Util.HasBasePartFallenToVoid() Util . HasBasePartFallenToVoid ( basePart : BasePart ) --> boolean [HasBasePartFallenToVoid] Arguments Description basePart : BasePart A BasePart Returns a boolean indicating if basePart has fallen to void, i.e basePart.Position.Y equals or is lower than Workspace.FallenPartsDestroyHeight . Util.IsBasePartFalling() Util . IsBasePartFalling ( basePart : basePart , lastPosition : Vector3 ) --> boolean[IsBasePartFalling] Returns a boolean indicating if basePart is falling, i.e basePart.Position.Y is lower than lastPosition.Y . Arguments Description basePart : BasePart A BasePart lastPosition : Vector3 A Vector3 Util.IsInstanceDestroyed() Util . IsInstanceDestroyed ( instance : Instance , lastPosition : Vector3 ) --> boolean[IsInstanceDestroyed] Returns a boolean indicating if instance is destroyed, i.e via Instance:Destroy . Arguments Description instance : Instance An Instance lastPosition : Vector3 A Vector3 Util.SetBasePartNetworkOwner() Util . SetBasePartNetworkOwner ( basePart : BasePart , networkOwner : player | nil ) --> nil [] Sets the network owner of basePart to networkOwner . Arguments Description basePart : BasePart A BasePart lastPosition : Vector3 A Vector3 Note This method will warn if the network ownership of basePart can't be set, along with the reason. Util.GetBasePartNetworkOwner() Util . GetBasePartNetworkOwner ( basePart : BasePart ) --> Player | nil [BasePartNetworkOwner] Returns the network owner of basePart . Arguments Description basePart : BasePart A BasePart Note This method will return nil if basePart is anchored. Util.IsPlayerWalking() Util . IsPlayerWalking ( player : Player , lastPosition : Vector3 ) --> boolean [IsPlayerWalking] Returns a boolean indicating if player is falling by comparing if player.Character.PrimaryPart.Position.Y is lower than lastPosition.Y . Arguments Description player : Player A Player object lastPosition : Vector3 A Vector3 Note This method will return false if player 's character isn't loaded. Util.DoValidPlayerBodyPartsExist() Util . DoValidPlayerBodyPartsExist ( player : Player ) --> boolean [DoValidPlayerBodyPartsExist] Returns a boolean indicating if player has the primary part and a humanoid inside their character. Arguments Description player : Player A Player object Note This method will return false if player 's character isn't loaded.","title":"Util"},{"location":"Shared/Util/#util","text":"The Util module is a simply module which provides a few basic instance methods associated to instances and players.","title":"Util"},{"location":"Shared/Util/#utilgetplayerequippedtools","text":"Util . GetPlayerEquippedTools ( player : Player ) --> table [equippedTools], number [equippedToolsCount] Returns an array of the tools equipped by the player, along with the number of tools equipped. Arguments Description player : Player A Player object","title":"Util.GetPlayerEquippedTools()"},{"location":"Shared/Util/#utilhasbasepartfallentovoid","text":"Util . HasBasePartFallenToVoid ( basePart : BasePart ) --> boolean [HasBasePartFallenToVoid] Arguments Description basePart : BasePart A BasePart Returns a boolean indicating if basePart has fallen to void, i.e basePart.Position.Y equals or is lower than Workspace.FallenPartsDestroyHeight .","title":"Util.HasBasePartFallenToVoid()"},{"location":"Shared/Util/#utilisbasepartfalling","text":"Util . IsBasePartFalling ( basePart : basePart , lastPosition : Vector3 ) --> boolean[IsBasePartFalling] Returns a boolean indicating if basePart is falling, i.e basePart.Position.Y is lower than lastPosition.Y . Arguments Description basePart : BasePart A BasePart lastPosition : Vector3 A Vector3","title":"Util.IsBasePartFalling()"},{"location":"Shared/Util/#utilisinstancedestroyed","text":"Util . IsInstanceDestroyed ( instance : Instance , lastPosition : Vector3 ) --> boolean[IsInstanceDestroyed] Returns a boolean indicating if instance is destroyed, i.e via Instance:Destroy . Arguments Description instance : Instance An Instance lastPosition : Vector3 A Vector3","title":"Util.IsInstanceDestroyed()"},{"location":"Shared/Util/#utilsetbasepartnetworkowner","text":"Util . SetBasePartNetworkOwner ( basePart : BasePart , networkOwner : player | nil ) --> nil [] Sets the network owner of basePart to networkOwner . Arguments Description basePart : BasePart A BasePart lastPosition : Vector3 A Vector3 Note This method will warn if the network ownership of basePart can't be set, along with the reason.","title":"Util.SetBasePartNetworkOwner()"},{"location":"Shared/Util/#utilgetbasepartnetworkowner","text":"Util . GetBasePartNetworkOwner ( basePart : BasePart ) --> Player | nil [BasePartNetworkOwner] Returns the network owner of basePart . Arguments Description basePart : BasePart A BasePart Note This method will return nil if basePart is anchored.","title":"Util.GetBasePartNetworkOwner()"},{"location":"Shared/Util/#utilisplayerwalking","text":"Util . IsPlayerWalking ( player : Player , lastPosition : Vector3 ) --> boolean [IsPlayerWalking] Returns a boolean indicating if player is falling by comparing if player.Character.PrimaryPart.Position.Y is lower than lastPosition.Y . Arguments Description player : Player A Player object lastPosition : Vector3 A Vector3 Note This method will return false if player 's character isn't loaded.","title":"Util.IsPlayerWalking()"},{"location":"Shared/Util/#utildovalidplayerbodypartsexist","text":"Util . DoValidPlayerBodyPartsExist ( player : Player ) --> boolean [DoValidPlayerBodyPartsExist] Returns a boolean indicating if player has the primary part and a humanoid inside their character. Arguments Description player : Player A Player object Note This method will return false if player 's character isn't loaded.","title":"Util.DoValidPlayerBodyPartsExist()"}]}