{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Octagon Octagon is a fully fledged modular anti exploit designed to detect many exploits reliably without interrupting user experience. Supported detections Physics : High horizontal speed High vertical speed NoClip NonPhysics : Invalid tool deletion Multi tool equip Invalid humanoid deletion Invalid humanoid root part deletion Why use Octagon over anti exploits? Doesn't perform heavy computation and reserves resources - Octagon is an extremely performant anti exploit as it doesn't perform heavy computation. Many other anti exploits perform very poorly which is bad for both developer experience and games. Easiness of usage - Octagon is very easy to use and can be easily imported to your game without any headaches. It doesn't provide bloated methods and allows you to use it to it's fullest capability. Handles nightmarish edge cases no developer would ever dare to fix - Octagon is the most reliable anti exploit as of writing, and handles a lot of nightmarish edge cases which are guaranteed to arise when developing a reliable anti exploit. Built for flexibility and massive scalability - Octagon is extremely flexible, you can add your own checks alongside others without any headaches and is built to perform in large-player servers reliably. It spreads a single Heartbeat event for all players in the game. Future proof - Octagon already provides group configuration support along side manual player blacklisting so you'll never be left in the dark and will almost never interrupt UX except very slightly in a rare case .","title":"Home"},{"location":"#octagon","text":"Octagon is a fully fledged modular anti exploit designed to detect many exploits reliably without interrupting user experience.","title":"Octagon"},{"location":"#supported-detections","text":"Physics : High horizontal speed High vertical speed NoClip NonPhysics : Invalid tool deletion Multi tool equip Invalid humanoid deletion Invalid humanoid root part deletion","title":"Supported detections"},{"location":"#why-use-octagon-over-anti-exploits","text":"Doesn't perform heavy computation and reserves resources - Octagon is an extremely performant anti exploit as it doesn't perform heavy computation. Many other anti exploits perform very poorly which is bad for both developer experience and games. Easiness of usage - Octagon is very easy to use and can be easily imported to your game without any headaches. It doesn't provide bloated methods and allows you to use it to it's fullest capability. Handles nightmarish edge cases no developer would ever dare to fix - Octagon is the most reliable anti exploit as of writing, and handles a lot of nightmarish edge cases which are guaranteed to arise when developing a reliable anti exploit. Built for flexibility and massive scalability - Octagon is extremely flexible, you can add your own checks alongside others without any headaches and is built to perform in large-player servers reliably. It spreads a single Heartbeat event for all players in the game. Future proof - Octagon already provides group configuration support along side manual player blacklisting so you'll never be left in the dark and will almost never interrupt UX except very slightly in a rare case .","title":"Why use Octagon over anti exploits?"},{"location":"basicusage/","text":"Basic usage Here's some basic serversided code which starts up Octagon and listens to player's exploit detection flags: local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Players = game : GetService ( \"Players\" ) local Octagon = require ( ReplicatedStorage . Octagon ) local PlayerProfile = require ( Octagon . PlayerProfile ) -- Start up Octagon: Octagon . Start () -- Get each player's profile and listen to new exploit detections: local function PlayerAdded ( player ) local profile = PlayerProfile . GetPlayerProfile ( player ) -- Safe check as the player's profile will not exist if the player -- isn't being monitored by the anti exploit: if not profile then return end -- Listen to new exploit flags: profile . OnNewDetectionFlag : Connect ( function ( detectionName ) warn (( \"%s got flagged for %s\" ): format ( player . Name , detectionName )) end ) end -- Scripts are deferred when they run, handle the edge case where players are already -- in the game by the time this script runs: for _ , player in ipairs ( Players : GetPlayers ()) do task . spawn ( PlayerAdded , player ) end Players . PlayerAdded : Connect ( PlayerAdded ) Additionally, here is a very basic client side code which starts up Octagon on the client side: local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Octagon = require ( ReplicatedStorage . Octagon ) -- Start up octagon: Octagon . Start ()","title":"Basic usage"},{"location":"basicusage/#basic-usage","text":"Here's some basic serversided code which starts up Octagon and listens to player's exploit detection flags: local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Players = game : GetService ( \"Players\" ) local Octagon = require ( ReplicatedStorage . Octagon ) local PlayerProfile = require ( Octagon . PlayerProfile ) -- Start up Octagon: Octagon . Start () -- Get each player's profile and listen to new exploit detections: local function PlayerAdded ( player ) local profile = PlayerProfile . GetPlayerProfile ( player ) -- Safe check as the player's profile will not exist if the player -- isn't being monitored by the anti exploit: if not profile then return end -- Listen to new exploit flags: profile . OnNewDetectionFlag : Connect ( function ( detectionName ) warn (( \"%s got flagged for %s\" ): format ( player . Name , detectionName )) end ) end -- Scripts are deferred when they run, handle the edge case where players are already -- in the game by the time this script runs: for _ , player in ipairs ( Players : GetPlayers ()) do task . spawn ( PlayerAdded , player ) end Players . PlayerAdded : Connect ( PlayerAdded ) Additionally, here is a very basic client side code which starts up Octagon on the client side: local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Octagon = require ( ReplicatedStorage . Octagon ) -- Start up octagon: Octagon . Start ()","title":"Basic usage"},{"location":"settingup/","text":"Setting up Octagon is designed to be a module script that you need to place in ReplicatedStorage as both the server and client are supposed to access it. Through Roblox Studio Get the Roblox model here . Place it in ReplicatedStorage . Through Rojo Fork the repository . Use Rojo to sync the files to your project through an external code editor, preferably Visual Studio Code .","title":"Setting up"},{"location":"settingup/#setting-up","text":"Octagon is designed to be a module script that you need to place in ReplicatedStorage as both the server and client are supposed to access it.","title":"Setting up"},{"location":"settingup/#through-roblox-studio","text":"Get the Roblox model here . Place it in ReplicatedStorage .","title":"Through Roblox Studio"},{"location":"settingup/#through-rojo","text":"Fork the repository . Use Rojo to sync the files to your project through an external code editor, preferably Visual Studio Code .","title":"Through Rojo"},{"location":"troubleshooting/","text":"Troubleshooting Note Make sure that your Octagon module is completely up to date. It isn't a module which trades in reliability for laziness! False positives Octagon is a server sided anti exploit, meaning there will be sometimes false positives of physics exploits. Octagon is designed in such a way that it will never punish players (such as bans, kicks) for exploiting, as server sided anti exploits can't be perfect due to replication latency. Instead, it teleports them to their last position and temporarily takes away the player's network owner. Note Also make sure to require Octagon on the client side so it checks the humanoid state of the local player and prevents them from bouncing hard when they land on the ground to prevent false positives and prevent them from flinging. Players being monitored/detected despite being black listed in the Config module This is due to HTTP requests failing in a rare case, as Octagon checks player's group ranks which send in an internal HTTP GET request. Game / group owner of the game being detected despite Config.ShouldMonitorGameOwner = false This is due to the above problem (if the game is under a group), or game.CreatorId returning an invalid userid of the game's owner's actual user id, this only happens in Studio and make sure to tset this out in an actual published game. Octagon not detecting walk speed changes, script injections, ... Please know that Octagon is a server sided anti exploit, and acts exactly like filtering enabled but for physics and non physics exploits.","title":"Trouble shooting"},{"location":"troubleshooting/#troubleshooting","text":"Note Make sure that your Octagon module is completely up to date. It isn't a module which trades in reliability for laziness!","title":"Troubleshooting"},{"location":"troubleshooting/#false-positives","text":"Octagon is a server sided anti exploit, meaning there will be sometimes false positives of physics exploits. Octagon is designed in such a way that it will never punish players (such as bans, kicks) for exploiting, as server sided anti exploits can't be perfect due to replication latency. Instead, it teleports them to their last position and temporarily takes away the player's network owner. Note Also make sure to require Octagon on the client side so it checks the humanoid state of the local player and prevents them from bouncing hard when they land on the ground to prevent false positives and prevent them from flinging.","title":"False positives"},{"location":"troubleshooting/#players-being-monitoreddetected-despite-being-black-listed-in-the-config-module","text":"This is due to HTTP requests failing in a rare case, as Octagon checks player's group ranks which send in an internal HTTP GET request.","title":"Players being monitored/detected despite being black listed in the Config module"},{"location":"troubleshooting/#game-group-owner-of-the-game-being-detected-despite-configshouldmonitorgameowner-false","text":"This is due to the above problem (if the game is under a group), or game.CreatorId returning an invalid userid of the game's owner's actual user id, this only happens in Studio and make sure to tset this out in an actual published game.","title":"Game / group owner of the game being detected despite Config.ShouldMonitorGameOwner = false"},{"location":"troubleshooting/#octagon-not-detecting-walk-speed-changes-script-injections","text":"Please know that Octagon is a server sided anti exploit, and acts exactly like filtering enabled but for physics and non physics exploits.","title":"Octagon not detecting walk speed changes, script injections, ..."},{"location":"Client/API/","text":"API Warning You should never edit the source of Octagon or any of it's descendant modules. Octagon already gives you a lot of flexibility and control to configure how it should work. Octagon Public members Octagon.OnPlayerFling Octagon . OnPlayerFling < Signal > : table A signal which is fired whenever the player is flinged (when hit by a fast moving object). Note This signal is already connected internally by Octagon so that it stops the player from flinging whenever this signal is fired by zeroing out their velocity. However, you can connect to this signal and perform whatever logic when this signal fires. Octagon.OnPlayerHardGroundLand Octagon . OnPlayerHardGroundLand < Signal > : table A signal which is fired whenever the player lands on a ground in a \"hard way\". Note This signal is already connected internally by Octagon so that it stops the player from bouncing whenever this signal is fired by zeroing out their velocity's Y axis to prevent false positives in case. However, you can connect to this signal and perform whatever logic when this signal fires. Static methods Octagon.Start() Octagon . Start () < void > : nil Starts checking the humanoid state of the client for fling detections. Octagon.Stop() Octagon . Stop () < void > : nil Stops checking the humanoid state of the client for fling detections and cleans up all maids in use.","title":"API"},{"location":"Client/API/#api","text":"Warning You should never edit the source of Octagon or any of it's descendant modules. Octagon already gives you a lot of flexibility and control to configure how it should work.","title":"API"},{"location":"Client/API/#octagon","text":"","title":"Octagon"},{"location":"Client/API/#public-members","text":"","title":"Public members"},{"location":"Client/API/#octagononplayerfling","text":"Octagon . OnPlayerFling < Signal > : table A signal which is fired whenever the player is flinged (when hit by a fast moving object). Note This signal is already connected internally by Octagon so that it stops the player from flinging whenever this signal is fired by zeroing out their velocity. However, you can connect to this signal and perform whatever logic when this signal fires.","title":"Octagon.OnPlayerFling"},{"location":"Client/API/#octagononplayerhardgroundland","text":"Octagon . OnPlayerHardGroundLand < Signal > : table A signal which is fired whenever the player lands on a ground in a \"hard way\". Note This signal is already connected internally by Octagon so that it stops the player from bouncing whenever this signal is fired by zeroing out their velocity's Y axis to prevent false positives in case. However, you can connect to this signal and perform whatever logic when this signal fires.","title":"Octagon.OnPlayerHardGroundLand"},{"location":"Client/API/#static-methods","text":"","title":"Static methods"},{"location":"Client/API/#octagonstart","text":"Octagon . Start () < void > : nil Starts checking the humanoid state of the client for fling detections.","title":"Octagon.Start()"},{"location":"Client/API/#octagonstop","text":"Octagon . Stop () < void > : nil Stops checking the humanoid state of the client for fling detections and cleans up all maids in use.","title":"Octagon.Stop()"},{"location":"Server/API/","text":"API Warning You should never edit the source of Octagon or any of it's descendant modules. Octagon already gives you a lot of flexibility and control to configure how it should work. Note Octagon will not monitor players whose profiles were cleaned up / not loaded. Octagon Public static methods Octagon.Start() Octagon . Start () < void > : nil Starts up Octagon and starts monitoring players who aren't black listed from being monitored. Octagon.Stop() Octagon . Stop () < void > : nil Stops Octagon and stops monitoring players, as well as cleaning up all maids in use. Octagon.BlacklistNoClipMonitoringParts() Octagon . BlacklistNoClipMonitoringParts ( parts : table ) < void > : nil Iterates through parts and adds a \"noclip black listed\" tag which will allow players to pass through those parts even if they aren't CanCollide true on the server.","title":"API"},{"location":"Server/API/#api","text":"Warning You should never edit the source of Octagon or any of it's descendant modules. Octagon already gives you a lot of flexibility and control to configure how it should work. Note Octagon will not monitor players whose profiles were cleaned up / not loaded.","title":"API"},{"location":"Server/API/#octagon","text":"","title":"Octagon"},{"location":"Server/API/#public-static-methods","text":"","title":"Public static methods"},{"location":"Server/API/#octagonstart","text":"Octagon . Start () < void > : nil Starts up Octagon and starts monitoring players who aren't black listed from being monitored.","title":"Octagon.Start()"},{"location":"Server/API/#octagonstop","text":"Octagon . Stop () < void > : nil Stops Octagon and stops monitoring players, as well as cleaning up all maids in use.","title":"Octagon.Stop()"},{"location":"Server/API/#octagonblacklistnoclipmonitoringparts","text":"Octagon . BlacklistNoClipMonitoringParts ( parts : table ) < void > : nil Iterates through parts and adds a \"noclip black listed\" tag which will allow players to pass through those parts even if they aren't CanCollide true on the server.","title":"Octagon.BlacklistNoClipMonitoringParts()"},{"location":"Server/Detections/","text":"Detections Octagon already comes with preinstalled physics and non physics detections of course. They can be extremely easily be configured for your own game's needs. Physics Each physics detection module, comes with a predefined set of values which you can toggle for your own game's need: -- SilentsReplacement -- HorizontalSpeed -- July 18, 2021 --[[ HorizontalSpeed.Start( detectionData <DetectionData> : table, playerProfile <PlayerProfileObject> : table, dt : number ) <void> : nil ]] local HorizontalSpeed = { Leeway = 8 , StartInterval = 0.3 , PlayerDetectionFlagExpireInterval = 4 , LeewayMultiplier = 2 , Enabled = true , -- For use internally by the anti exploit, don't touch _areSignalsInit = false } ... Public members Leeway For each physics threshold, an additional amount of value is considered which is referred to as Leeway . Note It is recommended to have this value set to a number greater or equals to 8 . StartInterval The interval (in seconds) at which the detection runs. PlayerDetectionFlagExpireInterval The interval (in seconds) at which the player(who is currently flagged by the detection)'s flag expires. Once their flag is expired, they will return to a normal state. Note It is recommended to have this value set to a number lower or equals to 4 for a fair and square user experience incase players (in a rare case) get flagged false positively. LeewayMultiplier The multiplier for the leeway, used internally by Octagon when calculating the max physics threshold. Note It is recommended to have this value set to a number greater or equals to 2 . Enabled A boolean indicating if this detection should run or not. NonPhysics Each non physics detection module, comes with a predefined set of values which you can toggle for your own game's need: -- SilentsReplacement -- HumanoidDeletion -- July 26, 2021 --[[ HumanoidDeletion.Start( player : Player, playerProfile <PlayerProfileObject> : table ) <void> : nil HumanoidDeletion.Cleanup() <void> : nil ]] local HumanoidDeletion = { Enabled = true , -- For use internally by this detection, don't mutate: _areSignalsInit = false , _wereSignalsCleanedUp = false , } ... Public members Enabled A boolean indicating if this detection should run or not.","title":"Detections"},{"location":"Server/Detections/#detections","text":"Octagon already comes with preinstalled physics and non physics detections of course. They can be extremely easily be configured for your own game's needs.","title":"Detections"},{"location":"Server/Detections/#physics","text":"Each physics detection module, comes with a predefined set of values which you can toggle for your own game's need: -- SilentsReplacement -- HorizontalSpeed -- July 18, 2021 --[[ HorizontalSpeed.Start( detectionData <DetectionData> : table, playerProfile <PlayerProfileObject> : table, dt : number ) <void> : nil ]] local HorizontalSpeed = { Leeway = 8 , StartInterval = 0.3 , PlayerDetectionFlagExpireInterval = 4 , LeewayMultiplier = 2 , Enabled = true , -- For use internally by the anti exploit, don't touch _areSignalsInit = false } ...","title":"Physics"},{"location":"Server/Detections/#public-members","text":"","title":"Public members"},{"location":"Server/Detections/#leeway","text":"For each physics threshold, an additional amount of value is considered which is referred to as Leeway . Note It is recommended to have this value set to a number greater or equals to 8 .","title":"Leeway"},{"location":"Server/Detections/#startinterval","text":"The interval (in seconds) at which the detection runs.","title":"StartInterval"},{"location":"Server/Detections/#playerdetectionflagexpireinterval","text":"The interval (in seconds) at which the player(who is currently flagged by the detection)'s flag expires. Once their flag is expired, they will return to a normal state. Note It is recommended to have this value set to a number lower or equals to 4 for a fair and square user experience incase players (in a rare case) get flagged false positively.","title":"PlayerDetectionFlagExpireInterval"},{"location":"Server/Detections/#leewaymultiplier","text":"The multiplier for the leeway, used internally by Octagon when calculating the max physics threshold. Note It is recommended to have this value set to a number greater or equals to 2 .","title":"LeewayMultiplier"},{"location":"Server/Detections/#enabled","text":"A boolean indicating if this detection should run or not.","title":"Enabled"},{"location":"Server/Detections/#nonphysics","text":"Each non physics detection module, comes with a predefined set of values which you can toggle for your own game's need: -- SilentsReplacement -- HumanoidDeletion -- July 26, 2021 --[[ HumanoidDeletion.Start( player : Player, playerProfile <PlayerProfileObject> : table ) <void> : nil HumanoidDeletion.Cleanup() <void> : nil ]] local HumanoidDeletion = { Enabled = true , -- For use internally by this detection, don't mutate: _areSignalsInit = false , _wereSignalsCleanedUp = false , } ...","title":"NonPhysics"},{"location":"Server/Detections/#public-members_1","text":"","title":"Public members"},{"location":"Server/Detections/#enabled_1","text":"A boolean indicating if this detection should run or not.","title":"Enabled"},{"location":"Server/PlayerProfile/","text":"PlayerProfile PlayerProfile A player profile or also referred to as a player profile object, in layman's terms, is simply a table which contains necessary data for Octagon and the developer to work with. Each player monitored by Octagon will have it's own profile created already by Octagon. Static methods Note This section only includes public members / static methods that aren't to be used by Octagon internally! PlayerProfile.GetPlayerProfile() PlayerProfile . GetPlayerProfile ( player : Player ) < PlayerProfileObject > : table | nil Returns the player 's profile. Note This method will temporarily yield the thread if there is no player profile loaded for player . This is the case when this method is called before Octagon creates one for the player. This method will return nil if the player isn't being monitored by Octagon. PlayerProfile.IsPlayerProfile() PlayerProfile . IsPlayerProfile ( self ) < IsPlayerProfile > : boolean Returns a boolean indicating if self is a player profile or not. PlayerProfile.ArePlayerProfilesLoaded() PlayerProfile . ArePlayerProfilesLoaded () < ArePlayerProfilesLoaded > : boolean Returns a boolean indicating if there are any player profiles loaded and not cleaned up. PlayerProfile.CleanupPlayerProfiles() PlayerProfile . CleanupPlayerProfiles () < void > : nil Cleans up all loaded player profiles. PlayerProfile.IsPlayerGameOwner() PlayerProfile . IsPlayerGameOwner ( player : Player ) < IsPlayerGameOwner > : boolean Return a boolean indicating if player is the owner of the game or the owner of the group the game is in. PlayerProfile.GetAllLoadedProfiles() PlayerProfile . GetAllLoadedProfiles () < LoadedProfiles > : table Returns all loaded player profiles. Public instance members Note This section only includes public members of an PlayerProfileObject which aren't used by Octagon only. PlayerProfileObject.OnNewDetectionFlag PlayerProfileObject . OnNewDetectionFlag < Signal > : table A signal which is fired whenever the player is flagged by a detection. PlayerProfileObject . OnNewDetectionFlag : Connect ( function ( detectionName ) warn (( \"%s was flagged for %s\" ): format ( PlayerProfileObject . Player , detectionName )) end ) Parameters Description detectionName A string, which is the name of the detection PlayerProfileObject.Player The player who owns this profile. PlayerProfileObject.Maid A maid object owned by this profile. PlayerProfileObject.DetectionFlagsHistory An array of flags accumulated by the player who owns this profile. PlayerProfileObject.DetectionFlags The number of detection flags accumulated by the player who owns this profile. Public instance methods Note This section only includes public methods of an PlayerProfileObject which aren't used by Octagon only. PlayerProfileObject:TemporarilyBlackListPlayerFromBeingMonitored() PlayerProfileObject : TemporarilyBlackListPlayerFromBeingMonitored ( value : number | function | RBXScriptSignal | Signal ) < void > : nil Temporarily black lists the player from being monitored by Octagon. Arguments Description value : number The player will be monitored again by Octagon after value seconds. value : function The function will be called and the player will be monitored again by Octagon when the function finishes executing. value : RBXScriptSignal | Signal value:Wait() will be called and once value:Wait() has finished yielding the thread, the player will be monitored again by Octagon. PlayerProfileObject:RegisterNewDetectionFlag() PlayerProfileObject : RegisterNewDetectionFlag ( detectionName : string ) < void > : nil Register a new flag, incrementing the player's flag by 1 and adds detectionName to the player profile's detection history and fires PlayerProfileObject.OnNewDetectionFlag passing in detectionName as the argument. PlayerProfileObject:IsPlayerDetectionFlagFree() PlayerProfileObject : IsPlayerDetectionFlagFree () < void > : nil Returns a boolean indicating if the player has an active flag by a physics detection or not. PlayerProfileObject:Cleanup() PlayerProfileObject : Cleanup () < void > : nil Cleans up all the maids used by the profile and sets reference type members in it to nil .","title":"PlayerProfile"},{"location":"Server/PlayerProfile/#playerprofile","text":"","title":"PlayerProfile"},{"location":"Server/PlayerProfile/#playerprofile_1","text":"A player profile or also referred to as a player profile object, in layman's terms, is simply a table which contains necessary data for Octagon and the developer to work with. Each player monitored by Octagon will have it's own profile created already by Octagon.","title":"PlayerProfile"},{"location":"Server/PlayerProfile/#static-methods","text":"Note This section only includes public members / static methods that aren't to be used by Octagon internally!","title":"Static methods"},{"location":"Server/PlayerProfile/#playerprofilegetplayerprofile","text":"PlayerProfile . GetPlayerProfile ( player : Player ) < PlayerProfileObject > : table | nil Returns the player 's profile. Note This method will temporarily yield the thread if there is no player profile loaded for player . This is the case when this method is called before Octagon creates one for the player. This method will return nil if the player isn't being monitored by Octagon.","title":"PlayerProfile.GetPlayerProfile()"},{"location":"Server/PlayerProfile/#playerprofileisplayerprofile","text":"PlayerProfile . IsPlayerProfile ( self ) < IsPlayerProfile > : boolean Returns a boolean indicating if self is a player profile or not.","title":"PlayerProfile.IsPlayerProfile()"},{"location":"Server/PlayerProfile/#playerprofileareplayerprofilesloaded","text":"PlayerProfile . ArePlayerProfilesLoaded () < ArePlayerProfilesLoaded > : boolean Returns a boolean indicating if there are any player profiles loaded and not cleaned up.","title":"PlayerProfile.ArePlayerProfilesLoaded()"},{"location":"Server/PlayerProfile/#playerprofilecleanupplayerprofiles","text":"PlayerProfile . CleanupPlayerProfiles () < void > : nil Cleans up all loaded player profiles.","title":"PlayerProfile.CleanupPlayerProfiles()"},{"location":"Server/PlayerProfile/#playerprofileisplayergameowner","text":"PlayerProfile . IsPlayerGameOwner ( player : Player ) < IsPlayerGameOwner > : boolean Return a boolean indicating if player is the owner of the game or the owner of the group the game is in.","title":"PlayerProfile.IsPlayerGameOwner()"},{"location":"Server/PlayerProfile/#playerprofilegetallloadedprofiles","text":"PlayerProfile . GetAllLoadedProfiles () < LoadedProfiles > : table Returns all loaded player profiles.","title":"PlayerProfile.GetAllLoadedProfiles()"},{"location":"Server/PlayerProfile/#public-instance-members","text":"Note This section only includes public members of an PlayerProfileObject which aren't used by Octagon only.","title":"Public instance members"},{"location":"Server/PlayerProfile/#playerprofileobjectonnewdetectionflag","text":"PlayerProfileObject . OnNewDetectionFlag < Signal > : table A signal which is fired whenever the player is flagged by a detection. PlayerProfileObject . OnNewDetectionFlag : Connect ( function ( detectionName ) warn (( \"%s was flagged for %s\" ): format ( PlayerProfileObject . Player , detectionName )) end ) Parameters Description detectionName A string, which is the name of the detection","title":"PlayerProfileObject.OnNewDetectionFlag"},{"location":"Server/PlayerProfile/#playerprofileobjectplayer","text":"The player who owns this profile.","title":"PlayerProfileObject.Player"},{"location":"Server/PlayerProfile/#playerprofileobjectmaid","text":"A maid object owned by this profile.","title":"PlayerProfileObject.Maid"},{"location":"Server/PlayerProfile/#playerprofileobjectdetectionflagshistory","text":"An array of flags accumulated by the player who owns this profile.","title":"PlayerProfileObject.DetectionFlagsHistory"},{"location":"Server/PlayerProfile/#playerprofileobjectdetectionflags","text":"The number of detection flags accumulated by the player who owns this profile.","title":"PlayerProfileObject.DetectionFlags"},{"location":"Server/PlayerProfile/#public-instance-methods","text":"Note This section only includes public methods of an PlayerProfileObject which aren't used by Octagon only.","title":"Public instance methods"},{"location":"Server/PlayerProfile/#playerprofileobjecttemporarilyblacklistplayerfrombeingmonitored","text":"PlayerProfileObject : TemporarilyBlackListPlayerFromBeingMonitored ( value : number | function | RBXScriptSignal | Signal ) < void > : nil Temporarily black lists the player from being monitored by Octagon. Arguments Description value : number The player will be monitored again by Octagon after value seconds. value : function The function will be called and the player will be monitored again by Octagon when the function finishes executing. value : RBXScriptSignal | Signal value:Wait() will be called and once value:Wait() has finished yielding the thread, the player will be monitored again by Octagon.","title":"PlayerProfileObject:TemporarilyBlackListPlayerFromBeingMonitored()"},{"location":"Server/PlayerProfile/#playerprofileobjectregisternewdetectionflag","text":"PlayerProfileObject : RegisterNewDetectionFlag ( detectionName : string ) < void > : nil Register a new flag, incrementing the player's flag by 1 and adds detectionName to the player profile's detection history and fires PlayerProfileObject.OnNewDetectionFlag passing in detectionName as the argument.","title":"PlayerProfileObject:RegisterNewDetectionFlag()"},{"location":"Server/PlayerProfile/#playerprofileobjectisplayerdetectionflagfree","text":"PlayerProfileObject : IsPlayerDetectionFlagFree () < void > : nil Returns a boolean indicating if the player has an active flag by a physics detection or not.","title":"PlayerProfileObject:IsPlayerDetectionFlagFree()"},{"location":"Server/PlayerProfile/#playerprofileobjectcleanup","text":"PlayerProfileObject : Cleanup () < void > : nil Cleans up all the maids used by the profile and sets reference type members in it to nil .","title":"PlayerProfileObject:Cleanup()"},{"location":"Shared/Util/","text":"Util The Util module is a low level module which provides a few basic instance methods associated to instances and players. Static methods Util.HasInstanceFallenToVoid Util . HasInstanceFallenToVoid ( instance < BasePart > : Instance ) < HasFallenToVoid > : boolean Returns a boolean indicating if instance has fallen to void, i.e the position of instance equals or is lower than Workspace.FallenPartsDestroyHeight . Util.IsInstanceFalling Util . IsInstanceFalling ( instance < BasePart > Instance , lastPosition : Vector3 ) < HasFallenToVoid > : boolean Returns a boolean indicating if instance is falling by comparing if instance.Position.Y is lower than lastPosition.Y . Util.IsInstanceDestroyed Util . IsInstanceDestroyed ( instance : Instance ) Returns a boolean indicating if instance is destroyed through Instance:Destroy or if parented to nil . Util.IsPlayerWalking Util . IsPlayerWalking ( player < Player > : Instance , lastPosition : Vector3 ) Returns a boolean indicating if player is falling by comparing if player.Character.PrimaryPart.Position.Y is lower than lastPosition.Y .","title":"Util"},{"location":"Shared/Util/#util","text":"The Util module is a low level module which provides a few basic instance methods associated to instances and players.","title":"Util"},{"location":"Shared/Util/#static-methods","text":"","title":"Static methods"},{"location":"Shared/Util/#utilhasinstancefallentovoid","text":"Util . HasInstanceFallenToVoid ( instance < BasePart > : Instance ) < HasFallenToVoid > : boolean Returns a boolean indicating if instance has fallen to void, i.e the position of instance equals or is lower than Workspace.FallenPartsDestroyHeight .","title":"Util.HasInstanceFallenToVoid"},{"location":"Shared/Util/#utilisinstancefalling","text":"Util . IsInstanceFalling ( instance < BasePart > Instance , lastPosition : Vector3 ) < HasFallenToVoid > : boolean Returns a boolean indicating if instance is falling by comparing if instance.Position.Y is lower than lastPosition.Y .","title":"Util.IsInstanceFalling"},{"location":"Shared/Util/#utilisinstancedestroyed","text":"Util . IsInstanceDestroyed ( instance : Instance ) Returns a boolean indicating if instance is destroyed through Instance:Destroy or if parented to nil .","title":"Util.IsInstanceDestroyed"},{"location":"Shared/Util/#utilisplayerwalking","text":"Util . IsPlayerWalking ( player < Player > : Instance , lastPosition : Vector3 ) Returns a boolean indicating if player is falling by comparing if player.Character.PrimaryPart.Position.Y is lower than lastPosition.Y .","title":"Util.IsPlayerWalking"}]}